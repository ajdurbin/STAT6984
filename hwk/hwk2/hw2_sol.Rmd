---
title: 'STAT6984: Homework 2'
author: "Alexander Durbin"
date: "September 13, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Problem 2

The following code defines the original `swap` function. We create a large vector `v` and call `swap` twice. Note that we run the code twice using `system.time()` to account for any background processes that may affect memory allocation, this way we can better identify differences.

```{r}
swap <- function(v, i, j) 
{ 
	tmp <- v[i]
	v[i] <- v[j]
	v[j] <- tmp 
}
v <- 1:1000000000
system.time(swap(v, i=1, j=2))
system.time(swap(v, i=1, j=2))
```

As in the homework prompt, we see that `swap` copies the large vector `v` before swapping the elements. This is an extremely inefficient function.

The following code is replicates switching the first and second elements of `v` using the console.

```{r, eval=TRUE, echo=TRUE}

v <- 1:1000000000
i <- 1
j <- 2

system.time({
  tmp <- v[1]
  v[1] <- v[2]
  v[2] <- tmp
})

system.time({
  tmp <- v[1]
  v[1] <- v[2]
  v[2] <- tmp
}) 

# export uses this destination for another command they're just destination
# env bash command

```

We see that the second call is instantaneous. This is because `v` is not copied into `swap` before evaluation.

The following code is our implimentation of `swap.eval` using `quote` and `eval`.

```{r, eval=TRUE, echo=TRUE}

v <- 1:1000000000

swap.eval <- function(v, i, j)
{
  eval(
    quote({tmp <- v[i]; v[i] <- v[j]; v[j] <- tmp}), 
    envir=parent.frame()
    )
}

system.time(swap.eval(v, i = i, j = j))

system.time(swap.eval(v, i = i, j = j))
```

We see that the second call of `swap.eval` is just as efficient as manually using the console, and still a large improvement over `swap`.

The following `swap.do` function uses the `do.call` function, which has options for `quote` and specifying `environment` for arguments. Arguments are entered as a list. `swap.do` is simply `swap` with an added `print` statement.

```{r, eval=TRUE, echo=TRUE}

v <- 1:1000000000

swap.do <- function(v, i, j) 
{ 
  tmp <- v[i]
  v[i] <- v[j]
  v[j] <- tmp 
  print(v[1:5])
}

system.time(
  do.call(
    swap.do,
    args = list(v, 1, 2),
    quote = TRUE,
    envir = parent.frame()
  )
)

system.time(
  do.call(
    swap.do,
    args = list(v, 1, 2),
    quote = TRUE,
    envir = parent.frame()
  )
)

```

Surprisingly `swap.do` is just as inefficient as `swap`. This is surprising as the `quote` and `environment` options in `do.call` would lead us to believe that there would be no copying involved. This must not be the case.

# Problem 4

### R Command Line Tools
- R CMD BATCH
    - Called with `R CMD BATCH [options] input_file output_file args`
    - By default produces a `.Rout` file with same name as `input_file`.
    - `.Rout` contains the input and output of running the commands in `input_file` in the `R` console.
    - Plots specified in `input_file` are placed in `Rplots.pdf` on separate pages.
    - Default options are not to save `.Rdata` and to not restore previous `.Rdata` when running scripts. Will need to manually use the `--save` or `--restore` switches while saving `.Rdata` in your script.
    - Does not write output to command line, `cat` arguments in `input_file` appear as console output in `.Rout`.
    - Execution of file is halted when error found in `.R` and no error output appears in console. Warnings are also not printed to console.
    - Can accept conole input using `args` option and `arg <- commandArgs(TRUE)` in `.R` file. Then can index `args` like a vector and assign the values as needed using `var <- eval(parse(text = arg[1]))`. Be clear to not put spaces in `args` as `stdin` uses `space` as a separator.
    
- Rscript
    - Called with `Rscript [options] [-e expr] file args`
    - `expr` is used in absence of `file` and will evaulate the command and print the output to the console.
    - Does not print console output from `file` unless it is a package conflict, warnings, or error.
    - Also prints plots from `file` on separate pages to `Rplots.pdf`.
    - `args` are similarly used as in `R CMD BATCH` with the appropriate `commandArgs(TRUE)` statement.
    - Does not write to `.Rout` file by default or have options to. If wanting to capture the console output, will need to explicitly write to a file or use log files.
    - Can run single line expressions using `Rscript -e command`.
    - `.Rdata` are not loaded by default.
    
The major difference between these two command line tools is console output. `Rscript` seems more useful for doing quick commands in a remote server whereas `R CMD BATCH` would be more useful for running large programs on a remote server. However, `Rscript` does print warnings and errors and that is incredibly useful when running large jobs, but when combined with log files this could be the superior option to `R CMD BATCH`.

### Compiling `.Rmd` Files

Assuming the user is in the directory containing the relevant files, the command to compile `.Rmd` files with accompanying `.R` file is

```{r, eval=FALSE}

knitr::knit(input = my_file, tangle = TRUE)

```

The `tangle = TRUE` argument will extract code chunks from the `.Rmd` file and place them in a `.R` file with the same name as `my_file` except if `output_file` was specified for `output` in the `knit` statement.
