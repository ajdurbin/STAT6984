---
title: "Homework 3"
subtitle: "STAT6984: Advanced Statistical Computing"
author: "Alexander Durbin"
date: "`r Sys.Date()`"
output: html_document
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
```

```{r include=FALSE}

library(tidyverse)
library(quantmod)
options("getSymbols.warning4.0" = FALSE)
options("getSymbols.yahoo.warning"=FALSE)
options(stringsAsFactors = FALSE)

```

# Problem 2

## Part A

`getSymbols` works similarly to `get.quotes` and `get.multiple.quotes` from class but has some slight differences. `getSymbols` *silently* loads the object into the Global Environment. That is, `my_data <- getSymbols(Symbol = 'F')` does not assign `my_data` to the returned value. Instead, `my_data` is assigned the *string*  `'F'` and then an `xts` object is assigned to `F`. This can be worked around by first using `setSymbolLookup(my_data = 'F')` and then calling `getSymbols(Symbol = my_data)`. So we need to use the `auto.assign = FALSE` switch in an assignment statement to get the behavior we expect. Additionally, the `env` option can be used to specify an environment other than the global environment if the user prefers. `getSymbols` is used similarly to our functions from class where `getSymbols(Symbols = 'stock')` or `getSymbols(Symbols = c('stock1', 'stock2', ...,))`. However, providing multiple symbols will load each stock into a separate `xts` object, and not in a single dataframe as in `get.multiple.quotes`. We will then need to `rbind` the various symbols as in `get.multiple.quotes` like in class. Also, `getSymbols` has a `scr = ` argument for specifying the source of the data and defaults to Yahoo!.

The function call uses the command line tool `curl` to connect with Yahoo! and then stores the crumb for the query.

The following function code is similar to `get.multiple.quotes` from class with a couple intermediate steps. Each of the returned objects from `getSymbols` is of type `xts`. We convert them to a dataframe first, modify the column names, and add a new "symbol" column and date column before binding them together.

```{r}

dow30.tickers <-
  c("MMM", "AXP", "AAPL", "BA", "CAT", "CVX","CSCO", "KO", 
    "DIS", "XOM", "GE", "GS", "HD", "IBM", "INTC", "JNJ",
    "JPM", "MCD", "MRK", "MSFT", "NKE", "PFE", "PG", "TRV", 
    "UTX", "UNH", "VZ", "V", "WMT")

my_getSymbols <- function(ticker){
  
  total <- NULL
  
  for (tck in ticker) {
    
    pckg <- getSymbols(Symbols = tck, auto.assign = FALSE)
    tmp <- as.data.frame(pckg, row.names = FALSE)
    tmp$Date <- index(pckg)
    colnames(tmp) <- stringr::str_extract(colnames(tmp), "[^.]*$")
    tmp$Symbol <- tck
    total <- rbind(total, tmp)
    
  }
  
  return(total)
  
}

dow30 <- my_getSymbols(dow30.tickers)

```

## Part B

The following code uses `transform` to compute `Mid`.

```{r}

dow30 <- transform(dow30, Date = as.Date(Date), Mid = (High + Low) / 2)

```

## Part C

The following code defines a new function to calculate returns.

```{r}

calc_returns <- function(your_data, tickers){
  
  new_col <- NULL
  
  for (tck in tickers){
    
    # get data by asset
    tmp <- your_data[your_data$Symbol == tck, ]
    # get the last n-1 values
    new <- tail(tmp, n = -1)
    # get first n-1 values
    old <- head(tmp, n = -1)
    # calculate return
    r <- (new$Mid - old$Mid) / old$Mid
    # make first value NA 
    r <- append(r, NA, after = 0)
    # append to total vector for return
    new_col <- append(new_col, r, after = length(new_col))
    
  }
  
  return(new_col)
  
}

dow30$Return <- calc_returns(dow30, dow30.tickers) 

```

## Part D

The following code calcualtes the Dow Jones Industrial Average (DJIA).

```{r}

ddConst <- 0.14523396877348

dcalc <- function(the_day, the_data){
  
  tmp <- the_data %>% 
    filter(Date == the_day) %>% 
    select(Mid)
  
  pckg <- sum(tmp) / ddConst
  return(pckg)
  
}

djia <- sapply(unique(dow30$date), function(g) dcalc(g, the_data = dow30))

```

NEED TO COMPARE TO YAHOO DJIA BUT WHICH COLUMN TO COMPARE TO?

## Part E

The following code produces a market-capitalization version of the DJIA.

## Part F

# Problem 3

```{r, echo = FALSE}

teach <- read.table('teach.csv', sep = ',', header = TRUE)
teach <- teach %>% 
  mutate(marry = ifelse(marry == TRUE, 'married', 'not married')) %>% 
  mutate(degree = as.factor(degree)) %>% 
  mutate(train = ifelse(train == TRUE, 'train', 'not train')) %>% 
  mutate(type = as.factor(type)) %>% 
  mutate(brk = ifelse(brk == TRUE, 'break', 'not break'))

```

The following code provides a plot of `salary` versus `months` by `sex`.

```{r}

ggplot(data = teach) + 
  geom_jitter(mapping = aes(x = months, y = salary, color = sex)) +
  ggtitle('Salary Versus Number of Months By Sex')

```

We see that for the first ~100 months, salary increases linearly with months worked. However after the ~100 month mark, there is significant variability in the teacher's salaries. Also it appears that for a given month, male salaries are higher than female salaries. We want to provide appropriate visualizations that show this difference is not just attributed to gender, that the other features of the data are influencing these differences.

Maybe marriage is a deciding factor. The following code produces bar charts based on sex and marriage status. 

```{r}

ggplot(data = teach) +
  geom_bar(mapping = aes(x = sex, fill = marry), position = position_dodge())

```

We see that no male teachers in this data are married. Additionally, there are about twice as many married females as nonmarried females. We next look at the distribution of female salaries based on marriage status. 

The following code produces boxplots of female salary distribution by marriage status. We also consider degree status as well. 

```{r}

females <- teach %>% 
  filter(sex == "F")

ggplot(data = females) +
  geom_boxplot(mapping = aes(x = marry, y = salary, fill = degree))

```

It appears that non-married females of degree status '1' earn more on average than their married counterparts. Conversely, married females of degree status '2' earn significantly more than their non-married counterparts. Furthermore, There no married females of degree type '1', with a single non-married counterpart.


The following code filters the data by teachers with degree status '0'. We provide a scatterplot and fitted regression lines by sex.

```{r}

teach <- teach %>% 
  filter(degree == 0)

ggplot(data = teach) +
  geom_jitter(mapping = aes(x = months, y = salary, color = sex)) +
  ggtitle('Salary Versus Number of Months By Sex With Degree "0"') +
  geom_smooth(mapping = aes(x = months, y = salary), se = FALSE, method = 'lm')

```

# Problem 4

For the hockey problem, the following code will execute `hockey.R` and print the standings sorted by conference and division.

```{r}
source("hockey.R")
```

`nhlstandings.sh` contains the following:

```{r, eval=FALSE}
Rscript -e "source('hockey.R')"
```